package de.unibi.agbi.biodwh2.core.etl;

import de.unibi.agbi.biodwh2.core.DataSource;
import de.unibi.agbi.biodwh2.core.Workspace;
import de.unibi.agbi.biodwh2.core.exceptions.ExporterException;
import de.unibi.agbi.biodwh2.core.exceptions.ExporterFormatException;
import de.unibi.agbi.biodwh2.core.io.obo.*;
import de.unibi.agbi.biodwh2.core.model.graph.Graph;
import de.unibi.agbi.biodwh2.core.model.graph.Node;
import de.unibi.agbi.biodwh2.core.model.graph.NodeBuilder;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class OntologyGraphExporter<D extends DataSource> extends GraphExporter<D> {
    private static final Logger LOGGER = LoggerFactory.getLogger(OntologyGraphExporter.class);

    public OntologyGraphExporter(final D dataSource) {
        super(dataSource);
    }

    @Override
    protected boolean exportGraph(final Workspace workspace, final Graph graph) throws ExporterException {
        final boolean ignoreObsolete = ignoreObsolete(workspace);
        graph.setNodeIndexPropertyKeys("id");
        try {
            final OboReader reader = new OboReader(dataSource.resolveSourceFilePath(workspace, getOntologyFileName()),
                                                   StandardCharsets.UTF_8);
            exportHeader(graph, reader.getHeader());
            exportEntries(ignoreObsolete, graph, reader);
        } catch (IOException e) {
            throw new ExporterFormatException("Failed to export '" + getOntologyFileName() + "'", e);
        }
        return true;
    }

    private void exportHeader(final Graph graph, final OboHeader header) {
        final NodeBuilder builder = graph.buildNode().withLabel("Header");
        builder.withPropertyIfNotNull("format_version", header.getFormatVersion());
        builder.withPropertyIfNotNull("data_version", header.getDataVersions());
        builder.withPropertyIfNotNull("date", header.getDate());
        builder.withPropertyIfNotNull("saved_by", header.getSavedBy());
        builder.withPropertyIfNotNull("auto_generated_by", header.getAutoGeneratedBy());
        builder.withPropertyIfNotNull("default_namespace", header.getDefaultNamespace());
        builder.withPropertyIfNotNull("remarks", header.getRemarks());
        builder.withPropertyIfNotNull("ontology", header.getOntology());
        builder.withPropertyIfNotNull("imports", header.getImports());
        final Node node = builder.build();
        final String[] subsetDefs = header.getSubsetDefs();
        if (subsetDefs != null) {
            for (final String subsetDef : subsetDefs) {
                final String[] parts = StringUtils.split(subsetDef, " ", 2);
                final String name = StringUtils.strip(parts[1].trim(), "\"");
                final Node subsetDefNode = graph.addNode("Subset", "id", parts[0], "name", name);
                graph.addEdge(node, subsetDefNode, "HAS_SUBSET");
            }
        }
    }

    private void exportEntries(final boolean ignoreObsolete, final Graph graph, final OboReader reader) {
        final Map<String, Map<String, List<Long>>> relationCache = new HashMap<>();
        for (final OboEntry entry : reader) {
            if (ignoreObsolete && Boolean.TRUE.equals(entry.isObsolete()))
                continue;
            if (entry instanceof OboTerm)
                exportTerm(graph, (OboTerm) entry, relationCache);
            else if (entry instanceof OboTypedef)
                exportTypedef(graph, (OboTypedef) entry, relationCache);
            else if (entry instanceof OboInstance)
                exportInstance(graph, (OboInstance) entry, relationCache);
            else if (LOGGER.isInfoEnabled())
                LOGGER.info("Ignoring unknown OBO entry of type '" + entry.getType() + "'");
        }
    }

    private void exportTerm(final Graph graph, final OboTerm term,
                            final Map<String, Map<String, List<Long>>> relationCache) {
        final NodeBuilder builder = graph.buildNode().withLabel(term.getType());
        populateBuilderWithEntry(builder, term);
        builder.withPropertyIfNotNull("builtin", term.builtin());
        final Node node = builder.build();
        handleRelationships(graph, term.isA(), "IS_A", node, relationCache);
        handleRelationships(graph, term.equivalentTo(), "EQUIVALENT_TO", node, relationCache);
        handleRelationships(graph, term.disjointFrom(), "DISJOINT_FROM", node, relationCache);
        handleRelationships(graph, term.unionOf(), "UNION_OF", node, relationCache);
        handleRelationships(graph, term.consider(), "CONSIDER", node, relationCache);
        handleRelationships(graph, term.replacedBy(), "REPLACED_BY", node, relationCache);
    }

    private void populateBuilderWithEntry(final NodeBuilder builder, final OboEntry entry) {
        builder.withProperty("id", entry.getId());
        builder.withPropertyIfNotNull("def", entry.getDef());
        builder.withPropertyIfNotNull("name", entry.getName());
        builder.withPropertyIfNotNull("namespace", entry.getNamespace());
        builder.withPropertyIfNotNull("subsets", entry.getSubsets());
        builder.withPropertyIfNotNull("comment", entry.getComment());
        builder.withPropertyIfNotNull("created_by", entry.getCreatedBy());
        builder.withPropertyIfNotNull("creation_date", entry.getCreationDate());
        builder.withPropertyIfNotNull("xrefs", entry.getXrefs());
        builder.withPropertyIfNotNull("alt_ids", entry.getAltIds());
        builder.withProperty("obsolete", entry.isObsolete());
        builder.withProperty("anonymous", entry.isAnonymous());
    }

    private void handleRelationships(final Graph graph, final String[] targetIds, final String relationName,
                                     final Node entryNode, final Map<String, Map<String, List<Long>>> relationCache) {
        if (targetIds != null) {
            for (final String targetId : targetIds) {
                if (targetId == null)
                    continue;
                final Node targetNode = graph.findNode("id", targetId);
                if (targetNode == null) {
                    relationCache.putIfAbsent(targetId, new HashMap<>());
                    relationCache.get(targetId).putIfAbsent(relationName, new ArrayList<>());
                    relationCache.get(targetId).get(relationName).add(entryNode.getId());
                } else
                    graph.addEdge(entryNode, targetNode, relationName);
            }
        }
        final String entryId = entryNode.getProperty("id");
        if (relationCache.containsKey(entryId)) {
            final Map<String, List<Long>> relations = relationCache.get(entryId);
            for (final String key : relations.keySet())
                for (final Long targetNodeId : relations.get(key))
                    graph.addEdge(targetNodeId, entryNode, key);
            relationCache.remove(entryId);
        }
    }

    private void exportTypedef(final Graph graph, final OboTypedef typedef,
                               final Map<String, Map<String, List<Long>>> relationCache) {
        final NodeBuilder builder = graph.buildNode().withLabel(typedef.getType());
        populateBuilderWithEntry(builder, typedef);
        builder.withPropertyIfNotNull("builtin", typedef.builtin());
        builder.withPropertyIfNotNull("is_class_level", typedef.isClassLevel());
        builder.withPropertyIfNotNull("is_inverse_functional", typedef.isInverseFunctional());
        builder.withPropertyIfNotNull("is_functional", typedef.isFunctional());
        builder.withPropertyIfNotNull("is_transitive", typedef.isTransitive());
        builder.withPropertyIfNotNull("is_anti_symmetric", typedef.isAntiSymmetric());
        builder.withPropertyIfNotNull("is_symmetric", typedef.isSymmetric());
        builder.withPropertyIfNotNull("is_reflexive", typedef.isReflexive());
        builder.withPropertyIfNotNull("is_cyclic", typedef.isCyclic());
        builder.withPropertyIfNotNull("is_metadata_tag", typedef.isMetadataTag());
        final Node node = builder.build();
        handleRelationships(graph, typedef.isA(), "IS_A", node, relationCache);
        handleRelationships(graph, typedef.equivalentTo(), "EQUIVALENT_TO", node, relationCache);
        handleRelationships(graph, typedef.disjointFrom(), "DISJOINT_FROM", node, relationCache);
        handleRelationships(graph, typedef.unionOf(), "UNION_OF", node, relationCache);
        handleRelationships(graph, new String[]{typedef.getDomain()}, "HAS_DOMAIN", node, relationCache);
        handleRelationships(graph, new String[]{typedef.getRange()}, "HAS_RANGE", node, relationCache);
        handleRelationships(graph, typedef.consider(), "CONSIDER", node, relationCache);
        handleRelationships(graph, typedef.inverseOf(), "INVERSE_OF", node, relationCache);
        handleRelationships(graph, typedef.transitiveOver(), "TRANSITIVE_OVER", node, relationCache);
        handleRelationships(graph, typedef.disjointOver(), "DISJOINT_OVER", node, relationCache);
        handleRelationships(graph, typedef.replacedBy(), "REPLACED_BY", node, relationCache);
    }

    private void exportInstance(final Graph graph, final OboInstance instance,
                                final Map<String, Map<String, List<Long>>> relationCache) {
        final NodeBuilder builder = graph.buildNode().withLabel(instance.getType());
        populateBuilderWithEntry(builder, instance);
        final Node node = builder.build();
        handleRelationships(graph, instance.consider(), "CONSIDER", node, relationCache);
        handleRelationships(graph, new String[]{instance.instanceOf()}, "INSTANCE_IF", node, relationCache);
        handleRelationships(graph, instance.replacedBy(), "REPLACED_BY", node, relationCache);
    }

    protected abstract String getOntologyFileName();

    protected final boolean ignoreObsolete(final Workspace workspace) {
        final Map<String, String> properties = dataSource.getProperties(workspace);
        return "true".equalsIgnoreCase(properties.get("ignoreObsolete"));
    }
}
